// Code generated by MockGen. DO NOT EDIT.
// Source: contracts.go

// Package service is a generated GoMock package.
package service

import (
	context "context"
	reflect "reflect"
	time "time"

	entity "github.com/dayanaadylkhanova/click-counter/internal/entity"
	gomock "github.com/golang/mock/gomock"
)

// MockAggregatorPort is a mock of AggregatorPort interface.
type MockAggregatorPort struct {
	ctrl     *gomock.Controller
	recorder *MockAggregatorPortMockRecorder
}

// MockAggregatorPortMockRecorder is the mock recorder for MockAggregatorPort.
type MockAggregatorPortMockRecorder struct {
	mock *MockAggregatorPort
}

// NewMockAggregatorPort creates a new mock instance.
func NewMockAggregatorPort(ctrl *gomock.Controller) *MockAggregatorPort {
	mock := &MockAggregatorPort{ctrl: ctrl}
	mock.recorder = &MockAggregatorPortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAggregatorPort) EXPECT() *MockAggregatorPortMockRecorder {
	return m.recorder
}

// Inc mocks base method.
func (m *MockAggregatorPort) Inc(bannerID int64, now time.Time) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Inc", bannerID, now)
}

// Inc indicates an expected call of Inc.
func (mr *MockAggregatorPortMockRecorder) Inc(bannerID, now interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Inc", reflect.TypeOf((*MockAggregatorPort)(nil).Inc), bannerID, now)
}

// Run mocks base method.
func (m *MockAggregatorPort) Run(ctx context.Context) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Run", ctx)
}

// Run indicates an expected call of Run.
func (mr *MockAggregatorPortMockRecorder) Run(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockAggregatorPort)(nil).Run), ctx)
}

// Stop mocks base method.
func (m *MockAggregatorPort) Stop(ctx context.Context) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Stop", ctx)
}

// Stop indicates an expected call of Stop.
func (mr *MockAggregatorPortMockRecorder) Stop(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockAggregatorPort)(nil).Stop), ctx)
}

// MockStatsReaderPort is a mock of StatsReaderPort interface.
type MockStatsReaderPort struct {
	ctrl     *gomock.Controller
	recorder *MockStatsReaderPortMockRecorder
}

// MockStatsReaderPortMockRecorder is the mock recorder for MockStatsReaderPort.
type MockStatsReaderPortMockRecorder struct {
	mock *MockStatsReaderPort
}

// NewMockStatsReaderPort creates a new mock instance.
func NewMockStatsReaderPort(ctrl *gomock.Controller) *MockStatsReaderPort {
	mock := &MockStatsReaderPort{ctrl: ctrl}
	mock.recorder = &MockStatsReaderPortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStatsReaderPort) EXPECT() *MockStatsReaderPortMockRecorder {
	return m.recorder
}

// QueryRange mocks base method.
func (m *MockStatsReaderPort) QueryRange(ctx context.Context, bannerID int64, from, to time.Time) ([]entity.Point, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryRange", ctx, bannerID, from, to)
	ret0, _ := ret[0].([]entity.Point)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QueryRange indicates an expected call of QueryRange.
func (mr *MockStatsReaderPortMockRecorder) QueryRange(ctx, bannerID, from, to interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryRange", reflect.TypeOf((*MockStatsReaderPort)(nil).QueryRange), ctx, bannerID, from, to)
}

// MockAggregateWriter is a mock of AggregateWriter interface.
type MockAggregateWriter struct {
	ctrl     *gomock.Controller
	recorder *MockAggregateWriterMockRecorder
}

// MockAggregateWriterMockRecorder is the mock recorder for MockAggregateWriter.
type MockAggregateWriterMockRecorder struct {
	mock *MockAggregateWriter
}

// NewMockAggregateWriter creates a new mock instance.
func NewMockAggregateWriter(ctrl *gomock.Controller) *MockAggregateWriter {
	mock := &MockAggregateWriter{ctrl: ctrl}
	mock.recorder = &MockAggregateWriterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAggregateWriter) EXPECT() *MockAggregateWriterMockRecorder {
	return m.recorder
}

// UpsertAggregates mocks base method.
func (m *MockAggregateWriter) UpsertAggregates(ctx context.Context, rows []AggregateRow) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpsertAggregates", ctx, rows)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpsertAggregates indicates an expected call of UpsertAggregates.
func (mr *MockAggregateWriterMockRecorder) UpsertAggregates(ctx, rows interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertAggregates", reflect.TypeOf((*MockAggregateWriter)(nil).UpsertAggregates), ctx, rows)
}
